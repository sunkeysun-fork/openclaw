# 飞书插件通讯安全分析

## 1. 架构概览

飞书插件支持两种连接模式与飞书服务器通讯：

- **WebSocket 模式**（默认）：插件主动连接飞书服务器，不暴露本地端口
- **Webhook 模式**：飞书服务器向本地 HTTP 服务推送事件回调

核心认证流程：`appId + appSecret` -> `tenant_access_token` (Bearer Token) -> 调用飞书 API。

相关代码位置：

| 模块                     | 文件                                      |
| ------------------------ | ----------------------------------------- |
| 客户端创建与缓存         | `extensions/feishu/src/client.ts`         |
| WebSocket / Webhook 监听 | `extensions/feishu/src/monitor.ts`        |
| Token 管理与流式卡片     | `extensions/feishu/src/streaming-card.ts` |
| 凭据解析与多账号管理     | `extensions/feishu/src/accounts.ts`       |
| 配置 Schema 校验         | `extensions/feishu/src/config-schema.ts`  |

---

## 2. WebSocket 通讯流程

### 2.1 连接建立时序图

```
┌──────────┐                        ┌──────────────────┐                     ┌──────────────────┐
│  插件端   │                        │  飞书 HTTPS API  │                     │ 飞书 WebSocket   │
│ WSClient │                        │  open.feishu.cn  │                     │    服务器         │
└────┬─────┘                        └────────┬─────────┘                     └────────┬─────────┘
     │                                       │                                        │
     │  1. POST /callback/ws/endpoint        │                                        │
     │  Body: { AppID, AppSecret }           │                                        │
     │ ────────────────────────────────────> │                                        │
     │           (HTTPS 加密)                 │                                        │
     │                                       │                                        │
     │  2. 返回 WSS 连接地址                  │                                        │
     │  { URL, ClientConfig }                │                                        │
     │  URL 含 device_id, service_id         │                                        │
     │ <──────────────────────────────────── │                                        │
     │                                       │                                        │
     │  3. 建立 WSS 连接                                                               │
     │  wss://...?device_id=xxx&service_id=xxx                                        │
     │ ─────────────────────────────────────────────────────────────────────────────> │
     │                            (TLS 加密)                                           │
     │                                                                                │
     │  4. 连接确认                                                                    │
     │ <───────────────────────────────────────────────────────────────────────────── │
     │                                                                                │
     │  ═══════════════════ 连接已建立，进入消息循环 ═══════════════════                  │
     │                                                                                │
     │  5. Ping (Protobuf Frame)                                                      │
     │  { method: control, headers: [type: ping] }                                    │
     │ ─────────────────────────────────────────────────────────────────────────────> │
     │                                                                                │
     │  6. Pong + 配置更新                                                             │
     │  { PingInterval, ReconnectCount, ... }                                         │
     │ <───────────────────────────────────────────────────────────────────────────── │
     │                                                                                │
     │  7. 事件推送 (Protobuf Frame)                                                   │
     │  { method: data, payload: 事件内容 }                                            │
     │ <───────────────────────────────────────────────────────────────────────────── │
     │                                                                                │
     │  8. 处理事件，调用飞书 API 回复                                                   │
     │  Authorization: Bearer <tenant_access_token>                                   │
     │ ────────────────────────────────────> │                                        │
     │           (HTTPS 加密)                 │                                        │
     │                                       │                                        │
```

### 2.2 消息格式

WebSocket 消息使用 Protobuf 序列化（非加密），帧结构：

```
Frame {
  SeqID:           uint64        // 序列号（递增）
  LogID:           uint64        // 日志追踪 ID
  service:         int32         // 服务标识（service_id）
  method:          int32         // 帧类型: control(0) / data(1)
  headers:         Header[]      // 控制头: type=ping/pong 等
  payloadEncoding: string        // 编码格式
  payloadType:     string        // 载荷类型
  payload:         bytes         // 事件内容（明文）
  LogIDNew:        string        // 新版日志 ID
}
```

### 2.3 重连机制

```
连接断开
  │
  ├─ 检查 reconnectCount（服务端下发）
  │
  ├─ 未超限 ──> 等待 reconnectInterval + random(reconnectNonce)
  │               │
  │               └─ 重新执行步骤 1（POST /callback/ws/endpoint）
  │                   │
  │                   └─ 获取新 URL，建立新 WSS 连接
  │
  └─ 已超限 ──> 停止重连，上报错误
```

---

## 3. 各通讯环节加密状态

### 3.1 出站请求（插件 -> 飞书 API）

| 环节                    | 传输加密   | 应用层加密 | 备注                                            |
| ----------------------- | ---------- | ---------- | ----------------------------------------------- |
| Token 换取 (appSecret)  | HTTPS      | 无         | appSecret 在 POST body 中明文传输，依赖 TLS     |
| API 调用 (Bearer Token) | HTTPS      | 无         | Token 在 Authorization 头中，依赖 TLS           |
| WebSocket 握手          | HTTPS      | 无         | appId/appSecret POST 到 `/callback/ws/endpoint` |
| WebSocket 消息          | WSS (TLS)  | 无         | Protobuf 序列化，非加密                         |
| 自定义 domain           | **不保证** | 无         | 代码未强制 HTTPS，允许 `http://` 前缀           |

### 3.2 入站请求（飞书 -> Webhook）

| 环节     | 传输加密         | 应用层加密        | 备注                               |
| -------- | ---------------- | ----------------- | ---------------------------------- |
| 事件回调 | **无** (裸 HTTP) | 可选 (encryptKey) | 需自行部署反向代理提供 TLS         |
| 验证机制 | -                | verificationToken | 静态 token，非签名，可被截获后伪造 |

### 3.3 WebSocket vs Webhook 安全对比

| 对比项     | WebSocket                    | Webhook                                  |
| ---------- | ---------------------------- | ---------------------------------------- |
| 暴露端口   | 不需要                       | 需要开放 HTTP 端口                       |
| 传输加密   | WSS (TLS) 默认开启           | 需自行配置 TLS 反向代理                  |
| 伪造请求   | 不适用（客户端发起）         | verificationToken 是静态值，可被截获伪造 |
| 应用层加密 | 无                           | 可选 (encryptKey AES-256-CBC)            |
| 攻击面     | 小                           | 大（公网可达的 HTTP 服务）               |
| 认证方式   | appSecret 换取一次性连接 URL | 每次请求携带 verificationToken           |

---

## 4. 凭据泄露风险分析

### 4.1 appId + appSecret 泄露

appSecret 是长期有效的静态凭据，泄露等于交出机器人完整控制权。

| 攻击能力                 | 说明                                                  |
| ------------------------ | ----------------------------------------------------- |
| 建立 WebSocket 连接      | 调用 `/callback/ws/endpoint` 获取新连接，接收所有事件 |
| 换取 tenant_access_token | 调用机器人权限范围内的任何 API                        |
| 发送消息                 | 以机器人身份向已授权的群/用户发消息                   |
| 读取消息                 | 读取机器人有权限的群聊历史                            |
| 访问文档/表格等资源      | 取决于机器人被授予的权限范围                          |
| 并行监听                 | 攻击者可以与合法连接同时存在，静默接收事件            |

**补救措施：** 飞书开发者后台重置 appSecret（旧 secret 立即失效）。

### 4.2 WSS 连接地址泄露

连接地址格式：`wss://...?device_id=xxx&service_id=xxx`

| 特性           | 说明                                   |
| -------------- | -------------------------------------- |
| 一次性绑定     | URL 为特定会话生成，与已建立的连接绑定 |
| 有时效性       | 会话由服务端管理，断开后可能失效       |
| 无法换取 token | 不含 appSecret，无法调用 API           |
| 无法发送消息   | 没有 tenant_access_token               |

**残余风险：** 如果连接尚未建立，攻击者可能抢先用该 URL 建立连接，截获事件消息。

### 4.3 泄露危害等级对比

```
泄露对象          有效期              能否调API    能否收消息    能否发消息    危害等级
─────────────────────────────────────────────────────────────────────────────────
appSecret        永久（手动重置前）    能          能           能           高
WSS 连接地址      单次会话 / 短期      不能        可能(抢连接)  不能          低
tenant_token     ~2小时               能          不能(直接)    能           中
```

---

## 5. appId/appSecret 的本质角色与消息流转

### 5.1 appId/appSecret 的作用

appId/appSecret **不是标识设备**，而是标识**飞书应用（机器人）本身**与飞书租户的绑定关系。它的作用是：

1. **建立通道** -- 让 openclaw 能以该机器人身份连接飞书服务器
2. **调用 API** -- 换取 tenant_access_token 后，以机器人身份发消息、读消息、获取用户信息

一个 appId/appSecret 可以在多台设备上同时使用（SDK 允许多个 WebSocket 连接并存），因此它标识的不是设备，而是**机器人应用实例**。

### 5.2 消息流转与鉴权边界

所有用户发给机器人的消息**都会到达 openclaw**，用户过滤发生在 openclaw 本地，而非飞书平台侧：

```
用户 A (已授权) ─┐
用户 B (未授权) ─┤──> 飞书服务器 ──> WebSocket ──> openclaw (本地)
用户 C (未授权) ─┘                                    │
                                                      ├─ A: 在 allowFrom 中 ──> 转发给 agent ──> 处理并回复
                                                      ├─ B: 不在 allowFrom 中 ──> pairing 流程，返回配对码
                                                      └─ C: 不在 allowFrom 中 ──> pairing 流程，返回配对码
```

**关键认知：** 飞书服务器不知道 openclaw 的 allowFrom 配置，它只负责把所有消息推送过来。鉴权是 openclaw 侧的本地逻辑判断（`bot.ts:662`），不是平台级权限控制。

### 5.3 用户鉴权机制（dmPolicy）

openclaw 内置三种 DM（私聊）策略，通过 `dmPolicy` 配置控制（`bot.ts:565`）：

#### pairing 模式（默认，推荐）

未授权用户发消息时触发配对流程，需要本地确认后才允许：

```
未授权用户发消息
  │
  ├─ 检查 allowFrom 列表 ──> 不在列表中
  │
  ├─ 生成一次性配对码
  │   存储: ~/.openclaw/credentials/feishu-pairing.json
  │   限制: 最多 3 个 pending，1 小时过期
  │
  ├─ 回复用户:
  │   "Your Feishu user id: ou_xxxxx"
  │   "Pairing code: XXXXXX"
  │
  └─ 本地终端确认配对码
      ├─ 确认 ──> open_id 写入 feishu-allowFrom.json，后续消息放行
      └─ 拒绝 ──> 用户被拒绝
```

相关代码（`bot.ts:662-693`）：

```typescript
if (dmPolicy === "pairing") {
  const { code, created } = await core.channel.pairing.upsertPairingRequest({
    channel: "feishu",
    id: ctx.senderOpenId,
    meta: { name: ctx.senderName },
  });
  // ... 发送配对码给用户
}
```

#### allowlist 模式（静态白名单）

仅允许配置中明确列出的用户，无配对流程。未授权用户的消息被静默丢弃。

#### open 模式（不推荐）

所有人都能和机器人对话并直达 agent。

### 5.4 白名单匹配规则

白名单**仅基于 ID 匹配**（open_id/user_id），不使用显示名称（`policy.ts:40`）：

```typescript
// Feishu allowlists are ID-based; mutable display names must never grant access.
const senderCandidates = [params.senderId, ...(params.senderIds ?? [])]
  .map((entry) => normalizeFeishuAllowEntry(String(entry ?? "")))
  .filter(Boolean);
```

支持的匹配方式：

- 精确 ID 匹配（如 `ou_xxxxx`）
- 通配符 `"*"`（允许所有）
- ID 归一化处理（去前缀、小写）

### 5.5 群聊鉴权

群聊有独立的策略层级（`bot.ts:569-612`）：

```
群消息到达
  │
  ├─ 1. groupPolicy 检查
  │     ├─ "disabled" ──> 拒绝所有群消息
  │     ├─ "open" ──> 允许所有群
  │     └─ "allowlist" ──> 检查 groupAllowFrom（群 ID 白名单）
  │
  ├─ 2. 群内发言者检查（可选）
  │     └─ groups.<chatId>.allowFrom ──> 限制群内哪些用户可以触发
  │
  └─ 3. @提及检查
        └─ requireMention（默认 true）──> 需要 @机器人 才触发
```

### 5.6 配置示例

```yaml
channels:
  feishu:
    appId: "cli_xxx"
    appSecret: "xxx"
    dmPolicy: "pairing" # 默认值，推荐
    allowFrom: # 静态白名单（与 pairing 叠加）
      - "ou_trusted_user_id_1"
      - "ou_trusted_user_id_2"
    groupPolicy: "allowlist" # open / allowlist / disabled
    groupAllowFrom:
      - "oc_group_chat_id_1" # 允许的群 ID
    groups:
      oc_group_chat_id_1:
        allowFrom: # 群内发言者白名单（可选）
          - "ou_specific_user"
        requireMention: true # 需要 @机器人
```

### 5.7 appSecret 泄露与 allowFrom 的关系

allowFrom 机制**无法防御 appSecret 泄露**。原因：

| 场景                     | 说明                                                                   |
| ------------------------ | ---------------------------------------------------------------------- |
| 攻击者另起 openclaw 实例 | 用泄露的 appSecret 建立独立连接，接收所有消息，不受你的 allowFrom 控制 |
| 攻击者并行监听           | 飞书允许同一 appId 多个 WebSocket 连接并存，攻击者可以静默接收事件     |
| 攻击者主动调用 API       | 用 token 直接调用飞书 API 发消息、读历史，完全绕过 openclaw            |

**结论：** allowFrom 保护的是"谁能触发你本地的 agent"，而不是"谁能访问机器人"。appSecret 泄露后，攻击者根本不需要经过你的 openclaw 实例。

### 5.8 鉴权机制安全评估

| 关注点                   | 保障状态 | 说明                                            |
| ------------------------ | -------- | ----------------------------------------------- |
| 未授权用户消息到达 agent | 受保护   | pairing/allowlist 模式下消息不会转发给 agent    |
| 白名单绕过风险           | 低       | 仅基于不可变的 ID 匹配，不使用显示名            |
| 配对码安全性             | 较好     | 一次性、1小时过期、最多 3 个 pending            |
| 已授权用户持久化         | 本地存储 | `~/.openclaw/credentials/feishu-allowFrom.json` |
| appSecret 泄露后的防护   | **无**   | allowFrom 是本地逻辑，攻击者可绕过              |

---

## 6. 多实例部署分析

### 6.1 同一 appId/appSecret 的多机器部署

飞书平台**不限制**同一个 appId/appSecret 在多少台设备上同时使用。每次调用 `/callback/ws/endpoint` 时，飞书服务端会分配独立的 `device_id`（SDK 源码 `index.js:85328-85340`），通过 device_id 区分不同连接而非限制连接数量。

```
                          ┌─ 机器 A: openclaw ──> WSS (device_id=aaa)
                          │
飞书应用 (appId/appSecret)┼─ 机器 B: openclaw ──> WSS (device_id=bbb)
                          │
                          └─ 机器 C: openclaw ──> WSS (device_id=ccc)
```

### 6.2 消息分发行为

多个实例同时连接时，飞书服务端的消息分发策略取决于飞书自身实现。从代码中的去重机制可以推断**广播模式的可能性较大**（每个连接都收到同一条消息）。

去重代码（`bot.ts:517-521`）：

```typescript
const messageId = event.message.message_id;
if (!(await tryRecordMessagePersistent(messageId, account.accountId, log))) {
  log(`feishu: skipping duplicate message ${messageId}`);
  return;
}
```

去重存储在本地磁盘（`~/.openclaw/credentials/`），各机器之间不共享，因此**每台机器会独立处理同一条消息**。

### 6.3 多实例场景下的行为

```
用户发送消息 "hello"
       │
       v
   飞书服务器
       │
       ├──> 机器 A 收到 "hello" ──> agent 回复 "Hi!"
       │
       └──> 机器 B 收到 "hello" ──> agent 回复 "Hello!"
                                         │
                                         v
                              用户收到两条不同的回复
```

| 场景                   | 结果                                                 |
| ---------------------- | ---------------------------------------------------- |
| 两台机器相同配置       | 用户收到重复或不一致的回复                           |
| 两台机器不同 allowFrom | 各自独立鉴权，机器 A 放行的用户在机器 B 上可能被拦截 |
| 一台是攻击者的         | 攻击者静默接收所有消息，用户无感知                   |

### 6.4 多实例与安全的关系

这是 appSecret 泄露危害大的根本原因 -- 飞书平台不区分"合法实例"和"非法实例"，只要 appId/appSecret 正确就能建立连接。openclaw 本地的 allowFrom 只控制自己这个实例的行为，对其他实例没有任何约束。

### 6.5 多机器部署建议

| 建议                       | 说明                                                   |
| -------------------------- | ------------------------------------------------------ |
| 为不同机器创建不同飞书应用 | 各自独立 appId/appSecret，互不影响                     |
| 飞书后台配置 IP 白名单     | 限制只有特定机器 IP 能使用该 appSecret                 |
| 监控并发连接数             | 同一 appId 出现异常数量的并行连接时告警                |
| 避免共享 appSecret         | 不要在多台机器间复制同一份凭据，除非有明确的多实例需求 |

---

## 7. Webhook 模式防护机制

当前实现中 Webhook 模式包含以下防护层（`monitor.ts`）：

```
入站请求
  │
  ├─ 1. 速率限制 ──> 120 req/min per IP，超限返回 429
  │
  ├─ 2. Content-Type 校验 ──> 仅允许 JSON，否则返回 415
  │
  ├─ 3. Body 大小限制 ──> 1MB 上限 + 30s 超时，超限返回 413/408
  │
  ├─ 4. Lark SDK 校验
  │     ├─ verificationToken 匹配检查
  │     └─ encryptKey 解密（如已配置）
  │
  └─ 5. 事件分发 ──> fire-and-forget 模式，3s 内返回响应
```

**verificationToken 的局限：** 它是对称的静态 token，飞书在 event body 中携带，SDK 校验是否匹配。这不是 HMAC 签名机制，没有时间戳防重放。一旦被截获，攻击者可以伪造 webhook 事件。

---

## 8. 安全改进建议

### 高优先级

| 建议                         | 说明                                                                          |
| ---------------------------- | ----------------------------------------------------------------------------- |
| 强制自定义 domain 使用 HTTPS | `client.ts` 和 `streaming-card.ts` 应校验自定义 domain 必须以 `https://` 开头 |
| 优先推荐 WebSocket 模式      | 攻击面显著小于 Webhook，文档中应作为默认推荐                                  |
| 飞书后台开启 IP 白名单       | 即使 appSecret 泄露，非白名单 IP 无法换取 token                               |

### 中优先级

| 建议                        | 说明                                                         |
| --------------------------- | ------------------------------------------------------------ |
| Webhook 必须配置 encryptKey | 当前可选，建议在 webhook 模式下强制要求                      |
| appSecret 加密存储          | 使用 OS keychain 或加密配置文件，避免明文存储                |
| Webhook 前置 TLS 反向代理   | 当前 HTTP server 裸跑，生产环境必须配置 nginx/caddy 提供 TLS |

### 低优先级

| 建议               | 说明                                            |
| ------------------ | ----------------------------------------------- |
| 凭据使用审计日志   | 记录 token 换取时间、来源 IP 等信息             |
| 连接异常告警       | 监测同一 appId 下的多连接并行，可能表明凭据泄露 |
| 定期轮换 appSecret | 建立 secret rotation 机制，缩小泄露窗口         |

---

## 9. 总结

飞书插件的安全体系分为两层：**传输安全**和**用户鉴权**，各有不同的保护范围和局限性。

**传输安全：**

- 完全依赖 TLS 传输层加密，没有独立的应用层加密保护（Webhook 的 encryptKey 可选但非默认）
- **WebSocket 模式**安全性优于 Webhook，核心优势在于攻击面小（不暴露端口、客户端主动连接），但消息内容在 TLS 内是 Protobuf 明文
- **Webhook 模式**需要额外部署 TLS 反向代理，且 verificationToken 存在被截获后伪造请求的风险
- 如果威胁模型包含 TLS 被绕过的场景（企业 SSL inspection 代理等），当前架构无法提供额外保护

**用户鉴权：**

- openclaw 内置 pairing/allowlist 机制，可以控制哪些用户的消息能触发本地 agent
- 鉴权发生在 openclaw 本地，飞书平台不感知 allowFrom 配置，所有用户的消息都会到达 openclaw
- allowFrom **无法防御 appSecret 泄露** -- 攻击者可以另起实例接收所有消息，完全绕过本地鉴权

**核心风险：**

- **appSecret** 是整个安全体系的核心，一旦泄露攻击者获得机器人完整控制权，allowFrom 无法提供保护
- 需要通过飞书平台侧的 IP 白名单 + 及时重置 appSecret 来缓解
- appSecret 标识的是机器人应用而非设备，泄露后攻击者可以在任意设备上并行监听
